<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
						http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd
						http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd">

	<import resource="classpath:specificApplicationContext.xml" />
    <import resource="classpath*:META-INF/ExtensionContext.xml" />
    <import resource="classpath:webserviceApplicationContext.xml" />
	<import resource="classpath:filecertmgmt.xml" />


	<bean id="pepsConfigLocation" class="java.lang.String">
		<constructor-arg value="${STORK.CONFIG.REPOSITORY:file:c:/Pgm/projects/configStork/tomcat/}peps.xml"/>
	</bean>
	<bean id="pepsUtilLocation" class="java.lang.String">
		<constructor-arg value="${STORK.CONFIG.REPOSITORY:file:c:/Pgm/projects/configStork/tomcat/}pepsUtil.properties"/>
	</bean>
	<bean id="specificProperties" class="java.lang.String">
		<constructor-arg value="${STORK.CONFIG.REPOSITORY:file:c:/Pgm/projects/configStork/tomcat/}specific.properties"/>
	</bean>

	<bean id="pepsProps" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
		<property name="location" ref="pepsConfigLocation"/>
	</bean>
	<!--bean id="commonProps" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
		<property name="location" ref="pepsUtilLocation"/>
	</bean-->
	<bean id="placeholderConfig"
		  class="eu.stork.peps.utils.PropertiesUtil">
		<property name="ignoreUnresolvablePlaceholders" value="true"/>
		<property name="order" value="0"/>
		<property name="locations">
			<list>
				<ref bean="pepsConfigLocation"/>
				<ref bean="specificProperties"/>
				<!--<value>file:c:\Pgm\projects\configStork\tomcat\peps.xml</value> <value>file:c:\Pgm\projects\configStork\tomcat\specific.properties</value> <value>file:c:\Pgm\projects\configStork\tomcat\pepsUtil.properties</value>-->
			</list>
		</property>
		<property name="fileEncoding" value="UTF-8" />
	</bean>

	<!-- PROPERTIES -->
    <bean id="applicationContextProvider" class="eu.stork.peps.ApplicationContextProvider" scope="singleton"></bean>

    <!-- Resource bundle to translate C-PEPS error codes -->
    <bean id="transMessageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
		<property name="basename" value="cpepstranslation"/>
	</bean>

	<!-- Resource bundle to log error messages to sys-admins -->
    <bean id="sysadminMessageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
		<property name="basename" value="sysadmin"/>
	</bean>
	
	<!-- Resource bundle to log error messages -->
    <bean id="errorMessageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
		<property name="basename" value="errors"/>
	</bean>

	<!-- SESSION Object -->
	<bean id="cPepsSession" class="${specific.session}" scope="session">
		<aop:scoped-proxy />
	</bean>

	<bean id="sPepsSession" class="${specific.session}" scope="session">
		<aop:scoped-proxy />
	</bean>

	<!-- LOGGING -->
	<bean id="cPepsLogger" class="${specific.logger}" />
	<bean id="sPepsLogger" class="${specific.logger}" />

	<!-- Commons Bean -->
	<bean id="PEPSUtil" class="eu.stork.peps.auth.commons.PEPSUtil">
		<property name="configs"><null/></property>
	</bean>

	<!-- SPECIFIC Classes -->

     <bean id="springManagedSecurityConfig" class="eu.stork.peps.security.ConfigurationSecurityBean" scope="prototype">
         <property name="ipMaxRequests" value="${max.requests.ip}" />
         <property name="spMaxRequests" value="${max.requests.sp}" />
         <property name="ipMaxTime" value="${max.time.ip}" />
         <property name="spMaxTime" value="${max.time.sp}" />
         <property name="trustedDomains" value="${trusted.sp.domains}" />
         <property name="validationMethod" value="${validation.method}" />
         <property name="messageSource" ref="errorMessageSource"/>
         <property name="isContentSecurityPolicyActive" value="${security.header.CSP.enabled:true}"/>
         <property name="isMoaActive" value="${isMoaActive:false}"/>
         <property name="includeXXssProtection" value="${security.header.XXssProtection.block:true}"/>
         <property name="includeXContentTypeOptions" value="${security.header.XContentTypeOptions.noSniff:true}"/>
         <property name="includeXFrameOptions" value="${security.header.XFrameOptions.sameOrigin:true}"/>
         <property name="includeHSTS" value="${security.header.HSTS.includeSubDomains:true}"/>
         <property name="includeMozillaDirectives" value="${security.header.CSP.includeMozillaDirectives:true}"/>
		 <property name="bypassValidation" value="${validation.bypass}" />
     </bean>

	<!-- ACTIONS -->
	<!-- EXCEPTION HANDLERS -->
<!--
	<bean id="springManagedExceptionHandler" class="eu.stork.peps.StorkPEPSExceptionHandlerAction"
		scope="prototype">
				<property name="messageSource" ref="sysadminMessageSource"/>
	</bean>
-->

<!--
	<bean id="springManagedInternalExceptionHandler" class="eu.stork.peps.InternalExceptionHandlerAction"
		scope="prototype" />
-->

<!--
	<bean id="springManagedCPEPSExceptionHandler" class="eu.stork.peps.CPEPSExceptionHandlerAction"
		scope="prototype" >
				<property name="messageSource" ref="sysadminMessageSource"/>
	</bean>
-->

	<!-- INTERCEPTOR -->
<!--
	<bean id="springManagedSecurityInterceptor" class="eu.stork.peps.security.SecurityRequestInterceptor"
		scope="prototype">
		<property name="ipMaxRequests" value="${max.requests.ip}" />
		<property name="spMaxRequests" value="${max.requests.sp}" />
		<property name="ipMaxTime" value="${max.time.ip}" />
		<property name="spMaxTime" value="${max.time.sp}" />
		<property name="trustedDomains" value="${trusted.sp.domains}" />
		<property name="validationMethod" value="${validation.method}" />
		<property name="messageSource" ref="errorMessageSource"/>
	</bean>

-->
<!--
    <bean id="springManagedContentSecurityPolicyInterceptor" class="eu.stork.peps.security.SecurityResponseHeaderInterceptor" scope="prototype">
        <property name="isContentSecurityPolicyActive" value="${security.header.CSP.enabled:true}"/>
        <property name="isMoaActive" value="${isMoaActive:false}"/>
        <property name="includeXXssProtection" value="${security.header.XXssProtection.block:true}"/>
        <property name="includeXContentTypeOptions" value="${security.header.XContentTypeOptions.noSniff:true}"/>
        <property name="includeXFrameOptions" value="${security.header.XFrameOptions.sameOrigin:true}"/>
        <property name="includeHSTS" value="${security.header.HSTS.includeSubDomains:true}"/>
        <property name="includeMozillaDirectives" value="${security.header.CSP.includeMozillaDirectives:true}"/>
    </bean>
-->
    <!-- SPeps requests parameters via servlet -->
    <bean id="sPepsController" class="eu.stork.peps.speps.SPepsControllerService" scope="prototype">
		<property name="session" ref="sPepsSession" />
		<property name="spepsService" ref="springManagedAUSPEPS" />
		<property name="assertionConsUrl" value="${speps.assertion.url}" />
        <!--property name="moaService" ref="springManagedMoaService" /-->
        <property name="pepsAuth" value="${speps.destination.url}" />
	</bean>
    <!-- CPeps requests parameters via servlet -->
    <bean id="cPepsController" class="eu.stork.peps.cpeps.CPepsControllerService" scope="prototype">
        <property name="session" ref="cPepsSession" />
        <property name="cpepsService" ref="springManagedAUCPEPS" />
        <property name="citizenConsentUrl" value="${cpeps.citizenConsentUrl}" />
        <property name="askConsentType" value="${cpeps.askconsent.type}" />
        <property name="callBackURL" value="${cpeps.specificidpredirect.url}" />
    </bean>

    <!-- Specific request parameters-->
    <!--<bean id="specificController" class="eu.stork.peps.servlet.SpecificCommonBeanmonBean" scope="prototype">
        <property name="cpepsService" ref="springManagedAUCPEPS" />
        <property name="session" ref="cPepsSession" />
    </bean>-->

    <!-- SP requests parameters -->
<!--
	<bean id="springManagedBkuAuthenticationAction" class="eu.stork.peps.BkuAuthenticationAction"
		scope="prototype">
		<property name="moaConfigData" ref="springManagedMoaConfigData" />
	</bean>
-->

	<!-- S-PEPS calls C-PEPS -->
<!--
	<bean id="springManagedColleagueRequestAction" class="eu.stork.peps.ColleagueRequestAction"
		scope="prototype">
		<property name="cpepsService" ref="springManagedAUCPEPS" />
		<property name="session" ref="cPepsSession" />
		<property name="citizenConsentUrl" value="${cpeps.citizenConsentUrl}" />
		<property name="askConsentType" value="${cpeps.askconsent.type}" />
	</bean>
-->

	<!-- Authenticate citizen -->
<!--
	<bean id="springManagedConsentTypeAction" class="eu.stork.peps.CitizenConsentAction"
		scope="prototype">
		<property name="cpepsService" ref="springManagedAUCPEPS" />
		<property name="session" ref="cPepsSession" />
		<property name="callbackURL" value="${cpeps.specificidpredirect.url}" />
		<property name="askConsentType" value="${cpeps.askconsent.type}" />
	</bean>
-->

	<!-- Validate IdP response -->
<!--
	<bean id="springManagedIdPResponseAction" class="eu.stork.peps.IdPResponseAction"
		scope="prototype">
		<property name="cpepsService" ref="springManagedAUCPEPS" />
		<property name="session" ref="cPepsSession" />
	</bean>
-->

	<!-- Present consent value -->
	<bean id="springManagedAPResponse" parent="cPepsController" class="eu.stork.peps.cpeps.APResponseBean"
		scope="prototype">
		<property name="askConsentValue" value="${cpeps.askconsent.value}" />
	</bean>

	<!-- S-PEPS answers to SP -->
<!--
	<bean id="springManagedColleagueResponseAction" class="eu.stork.peps.ColleagueResponseAction"
		scope="prototype">
		<property name="session" ref="sPepsSession" />
		<property name="spepsService" ref="springManagedAUSPEPS" />
        <property name="moaService" ref="springManagedMoaService" />
	</bean>
-->

    <!-- cspReportHandler -->
<!--
    <bean id="springManagedCspReportHandlerAction" class="eu.stork.peps.security.ContentSecurityPolicyReportAction" scope="prototype">
    </bean>
-->

	<!-- PEPS Classes -->
	<!-- CPEPS Classes -->
	<bean id="springManagedAUCPEPS" class="eu.stork.peps.auth.cpeps.AUCPEPS"
		scope="prototype">
		<property name="citizenService" ref="springManagedAUCPEPSCitizen" />
		<property name="samlService" ref="springManagedAUCPEPSSAML" />
		<property name="transService" ref="springManagedAUCPEPSTranslator" />
	</bean>

	<bean id="springManagedAUCPEPSTranslator" class="eu.stork.peps.auth.cpeps.AUCPEPSTranslator">
		<property name="specificPeps" ref="specificPeps" />
	</bean>

	<bean id="springManagedAUCPEPSCitizen" class="eu.stork.peps.auth.cpeps.AUCPEPSCitizen">
		<property name="cpepsUtil" ref="springManagedAUCPEPSUtil" />
	</bean>

	<bean id="springManagedAUCPEPSSAML" class="${AUCPEPSSAMLclass:eu.stork.peps.auth.cpeps.AUCPEPSSAML}">
		<property name="maxQAAlevel" value="${cpeps.maxQAAlevel}" />
		<property name="specificPeps" ref="specificPeps" />
		<property name="minQAA" value="${min.qaaLevel.value}" />
		<property name="maxQAA" value="${max.qaaLevel.value}" />
		<property name="countryCode" value="${cpeps.countrycode}" />
		<property name="loggerBean" ref="cPepsLogger" />
		<property name="messageSource" ref="errorMessageSource"/>
		<property name="cpepsUtil" ref="springManagedAUCPEPSUtil" />
		<property name="samlEngineInstanceName" value="${cpeps.saml.speps:CPEPS}" />
        <property name="storkSAMLEngineFactory" ref="samlEngineFactory" />
		<property name="cpepsMetadataUrl" value="${cpeps.metadata.url}"/>
		<property name="cpepsRequesterMetadataUrl" value="${cpeps.requester.metadata.url}"/>
		<property name="metadataProcessor" ref="pepsMetadataProcessor"/>
	</bean>
	<!-- SPEPS Classes -->
	<bean id="springManagedAUSPEPS" class="eu.stork.peps.auth.speps.AUSPEPS"
		scope="prototype">
		<property name="countryService" ref="springManagedAUSPEPSCountrySelector" />
		<property name="samlService" ref="springManagedAUSPEPSSAML" />
		<property name="transService" ref="springManagedAUSPEPSTranslator" />
		<property name="spApplication" value="${speps.spApplication}" />
		<property name="spCountry" value="${speps.spCountry}" />
		<property name="spInstitution" value="${speps.spInstitution}" />
		<property name="spSector" value="${speps.spSector}" />
		<property name="spepsUtil" ref="springManagedAUSPEPSUtil" />
	</bean>

	<bean id="springManagedAUSPEPSSAML" class="eu.stork.peps.auth.speps.AUSPEPSSAML">
		<property name="samlSpInstance" value="${saml.sp}" />
		<property name="samlCpepsInstance" value="${saml.cpeps}" />
		<property name="spepsUtil" ref="springManagedAUSPEPSUtil" />
		<property name="loggerBean" ref="sPepsLogger" />
		<property name="messageSource" ref="transMessageSource"/>
        <property name="checkCitizenCertificateCPepsCertificate" value="${check.citizenCertificate.cPepsCertificate}" />
        <property name="storkSAMLEngineFactory" ref="samlEngineFactory" />
		<property name="spepsMetadataUrl" value="${speps.metadata.url}"/>
		<property name="spepsResponderMetadataUrl" value="${speps.responder.metadata.url}"/>
		<property name="metadataProcessor" ref="pepsMetadataProcessor"/>
	</bean>

	<bean id="springManagedAUSPEPSCountrySelector" class="eu.stork.peps.auth.speps.AUSPEPSCountrySelector">
		<property name="destination" value="${speps.destination.url}" />
		<property name="spepsUtil" ref="springManagedAUSPEPSUtil" />
	</bean>

	<bean id="springManagedAUSPEPSTranslator" class="eu.stork.peps.auth.speps.AUSPEPSTranslator">
		<property name="specPeps" ref="specificPeps" />
	</bean>

    <!-- Defines the class used for the concurrent map implementation : functionality Session tracking & anti replay attack detection -->
    <!-- For testing usage only : this implementation should not be the default one, only for development, there is no expiration implemented-->
    <bean id="springManagedSPepsConcurrentMapProvider" class="eu.stork.peps.auth.ConcurrentMapServiceDefaultImpl">
    </bean>
    <bean id="springManagedCPepsConcurrentMapProvider" class="eu.stork.peps.auth.ConcurrentMapServiceDefaultImpl">
    </bean>

    <!-- Clustered and production ready implementation (use this in real world !) -->
    <!--bean id="springManagedCPepsConcurrentMapProvider" class="eu.stork.peps.auth.ConcurrentMapServiceDistributedImpl">
        <property name="hazelcastXmlConfigClassPathFileName" value="hazelcast.xml"/>
        <property name="antiReplayCacheName" value="antiReplayCacheCPeps"/>
    </bean>
    <bean id="springManagedSPepsConcurrentMapProvider" class="eu.stork.peps.auth.ConcurrentMapServiceDistributedImpl">
        <property name="hazelcastXmlConfigClassPathFileName" value="hazelcast.xml"/>
        <property name="antiReplayCacheName" value="antiReplayCacheSPeps"/>
    </bean-->

	<bean depends-on="springManagedSPepsConcurrentMapProvider" id="springManagedAUSPEPSUtil" class="eu.stork.peps.auth.speps.AUSPEPSUtil">
        <constructor-arg ref="springManagedSPepsConcurrentMapProvider"/>
		<property name="configs" ref="pepsProps" />
		<property name="bypassValidation" value="${validation.bypass}" />
		<property name="minQAA" value="${min.qaaLevel.value}" />
		<property name="maxQAA" value="${max.qaaLevel.value}" />
	</bean>

    <bean id="springManagedAUCPEPSUtil" class="eu.stork.peps.auth.cpeps.AUCPEPSUtil">
        <constructor-arg ref="springManagedCPepsConcurrentMapProvider"/>
		<property name="configs" ref="pepsProps" />
	</bean>
    <bean id="samlEngineFactory" class="eu.stork.peps.init.StorkSAMLEngineFactory" scope="singleton">
		<property name="engineConfigurationProvider" ref="engineConfiguration"/>
		<property name="pepsMetadataProcessor" ref="pepsMetadataProcessor"/>
    </bean>
    <bean id="pluginLoader" class="eu.stork.peps.utils.CountrySpecificUtil" scope="singleton">
    </bean>
	<bean id="pepsMetadataProcessor" class="eu.stork.peps.auth.metadata.PEPSMetadataProcessor" init-method="initProcessor">
		<property name="metadataRequestTimeout" value="${metadata.request.timeout:-1}"/>
		<property name="cache" ref="metadataCache${peps.run.environment:Prod}"/>
		<property name="fileMetadataLoader" ref="pepsFileMetadataProcessor"/>
		<property name="enableHttpRetrieval" value="${metadata.http.retrieval:true}"/>
		<property name="restrictHttp" value="${metadata.restrict.http:false}"/>
        <property name="validateEntityDescriptorSignature" value="${peps.metadata.check.signature:true}"/>
        <property name="trustedEntityDescriptors" value="${peps.metadata.not.signed.descriptors:}"/>
	</bean>
	<bean id="pepsFileMetadataProcessor" class="eu.stork.peps.auth.metadata.PEPSFileMetadataProcessor">
		<property name="repositoryPath" value="${metadata.file.repository}"/>
	</bean>
	<bean id="serviceMetadataGeneratorIDP" class="eu.stork.peps.utils.PEPSMetadataGenerator">
		<property name="samlCPEPSIDP" value="${cpeps.saml.speps:CPEPS}"/>
		<property name="cpepsMetadataUrl" value="${cpeps.metadata.url}"/>
		<property name="samlEngineFactory" ref="samlEngineFactory" />
		<property name="cpepsCountry" value="${cpeps.countrycode}" />
		<property name="cpepsUrl" value="${cpeps.node.url}" />
		<property name="pepsProps" ref="pepsProps" />
		<property name="validityDuration" value="${metadata.validity.duration:86400}" />
	</bean>
	<bean id="serviceMetadataGeneratorSP" class="eu.stork.peps.utils.PEPSMetadataGenerator">
		<property name="samlCPEPSSP" value="${cpeps.saml.idp:Specific}"/>
		<property name="cpepsMetadataUrl" value="${cpeps.requester.metadata.url}"/>
		<property name="samlEngineFactory" ref="samlEngineFactory" />
		<property name="cpepsCountry" value="${cpeps.countrycode}" />
		<property name="cpepsUrl" value="${cpeps.node.url}" />
		<property name="pepsProps" ref="pepsProps" />
		<property name="validityDuration" value="${metadata.validity.duration:86400}" />
		<!--property name="assertionUrl" value="${cpeps.assertion.url:missingSpepsAssertionUrl}" /-->
	</bean>
	<bean id="connectorMetadataGeneratorSP" class="eu.stork.peps.utils.PEPSMetadataGenerator">
		<property name="samlSPEPSSP" value="${saml.cpeps:SPEPS-CPEPS}"/>
		<property name="spepsMetadataUrl" value="${speps.metadata.url}"/>
		<property name="samlEngineFactory" ref="samlEngineFactory" />
		<property name="spepsCountry" value="${speps.spCountry}" />
		<property name="spepsUrl" value="${speps.node.url:}" />
		<property name="assertionUrl" value="${speps.assertion.url:missingSpepsAssertionUrl}" />
		<property name="pepsProps" ref="pepsProps" />
		<property name="validityDuration" value="${metadata.validity.duration:86400}" />
	</bean>
	<bean id="connectorMetadataGeneratorIDP" class="eu.stork.peps.utils.PEPSMetadataGenerator">
		<property name="samlSPEPSIDP" value="${saml.sp:SP-SPEPS}"/>
		<property name="spepsMetadataUrl" value="${speps.responder.metadata.url}"/>
		<property name="samlEngineFactory" ref="samlEngineFactory" />
		<property name="spepsCountry" value="${speps.spCountry}" />
		<property name="spepsUrl" value="${speps.node.url:}" />
		<property name="pepsProps" ref="pepsProps" />
		<property name="validityDuration" value="${metadata.validity.duration:86400}" />
	</bean>
	<bean id="pepsConfigDirectory" class="java.lang.String">
		<constructor-arg value="#{placeholderConfig.getPepsXmlLocation()}"/>
	</bean>

	<!--production -->
	<bean id="metadataCacheProd" class="eu.stork.peps.auth.metadata.DistributedMetadataCaching">
		<property name="mapName" value="pepsmetadata"/>
		<property name="hazelcastXmlConfigClassPathFileName" value="hazelcast.xml"/>
	</bean>

	<!-- for development environment -->
	<bean id="metadataCacheDev" class="eu.stork.peps.auth.metadata.SimpleMetadataCaching">
	</bean>
</beans>