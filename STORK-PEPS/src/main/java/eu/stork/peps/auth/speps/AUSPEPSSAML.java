/*
 * Copyright (c) 2015 by European Commission
 *
 * Licensed under the EUPL, Version 1.1 or - as soon they will be approved by
 * the European Commission - subsequent versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the Licence.
 * You may obtain a copy of the Licence at:
 * http://www.osor.eu/eupl/european-union-public-licence-eupl-v.1.1
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Licence for the specific language governing permissions and
 * limitations under the Licence.
 *
 * This product combines work with different licenses. See the "NOTICE" text
 * file for details on the various modules and licenses.
 * The "NOTICE" text file is part of the distribution. Any derivative works
 * that you distribute must include a readable copy of the "NOTICE" text file.
 *
 */

package eu.stork.peps.auth.speps;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import eu.stork.peps.auth.engine.SAMLEngineUtils;
import eu.stork.peps.auth.engine.metadata.MetadataProcessorI;
import eu.stork.peps.exceptions.SAMLEngineException;
import eu.stork.peps.init.StorkSAMLEngineFactory;
import eu.stork.peps.auth.commons.*;
import eu.stork.peps.auth.commons.exceptions.*;
import eu.stork.peps.logging.LoggingMarkerMDC;
import eu.stork.peps.utils.PEPSErrorUtil;
import eu.stork.peps.utils.PEPSValidationUtil;
import eu.stork.peps.utils.PropertiesUtil;
import eu.stork.peps.utils.SessionHolder;
import org.apache.commons.lang.StringUtils;
import org.opensaml.saml2.core.Attribute;
import org.opensaml.saml2.metadata.IDPSSODescriptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.MessageSource;

import eu.stork.peps.auth.engine.STORKSAMLEngine;
import eu.stork.peps.exceptions.STORKSAMLEngineException;
import org.springframework.context.NoSuchMessageException;

import javax.servlet.http.HttpSession;

/**
 * This class is used by {@link AUSPEPS} to get, process and generate SAML
 * Tokens.
 *
 * @see ISPEPSSAMLService
 */
public final class AUSPEPSSAML implements ISPEPSSAMLService {

        /**
         * Logger object.
         */
        private static final Logger LOG = LoggerFactory.getLogger(AUSPEPSSAML.class
                .getName());
        /**
         * Logger object.
         */
        private static final Logger logger = LoggerFactory.getLogger(AUSPEPSSAML.class
                .getName());

    /**
     * Request Stork logging.
     */
    private static final Logger LOGGER_COM_REQ = LoggerFactory
            .getLogger(PEPSValues.STORK_PACKAGE_REQUEST_LOGGER_VALUE.toString() + "."
                    + AUSPEPS.class.getSimpleName());

    /**
     * Response Stork logging.
     */
    private static final Logger LOGGER_COM_RESP = LoggerFactory
            .getLogger(PEPSValues.STORK_PACKAGE_RESPONSE_LOGGER_VALUE.toString() + "."
                    + AUSPEPS.class.getSimpleName());

    /**
     * Logger bean.
     */
    private IStorkLogger loggerBean;

    /**
     * SAML instance to communicate with SP.
     */
    private String samlSpInstance;

    /**
     * SAML instance to communicate with C-PEPS.
     */
    private String samlCpepsInstance;

    /**
     * S-PEPS's processAuthenticationResponse class.
     */
    private AUSPEPSUtil spepsUtil;

    /**
     * metadata url to be put in requests generated by the SPEPS module.
     */
    private String metadataUrl;

    /**
     * metadata url to be put in responses generated by the SPEPS module.
     */
    private String metadataResponderUrl;

    /**
     * Resource bundle to translate messages from C-PEPS/VIdP.
     */
    private MessageSource messageSource;

    private boolean checkCitizenCertificateCPepsCertificate;
    private StorkSAMLEngineFactory storkSAMLEngineFactory;

    public void setCheckCitizenCertificateCPepsCertificate(boolean checkCitizenCertificateCPepsCertificate) {
        this.checkCitizenCertificateCPepsCertificate = checkCitizenCertificateCPepsCertificate;
    }
    public StorkSAMLEngineFactory getStorkSAMLEngineFactory() {
        return storkSAMLEngineFactory;
    }

    public void setStorkSAMLEngineFactory(StorkSAMLEngineFactory storkSAMLEngineFactory) {
        this.storkSAMLEngineFactory = storkSAMLEngineFactory;
    }

    private MetadataProcessorI metadataProcessor;

    /**
     * {@inheritDoc}
     */
    public byte[] generateErrorAuthenticationResponse(final String inResponseTo,
                                                      final String issuer, final String destination, final String ipUserAddress,
                                                      final String statusCode, final String subCode, final String message) {
        STORKSAMLEngine engine=null;
        try {
            engine = getStorkSAMLEngineFactory().getEngine(samlSpInstance, getSpepsUtil() == null ? null : getSpepsUtil().getConfigs());
            // Generate SAMLResponse Fail.
            final STORKAuthnRequest request = new STORKAuthnRequest();
            request.setSamlId(inResponseTo);
            request.setIssuer(issuer);
            request.setAssertionConsumerServiceURL(destination);

            STORKAuthnResponse samlResponseFail = new STORKAuthnResponse();
            samlResponseFail.setStatusCode(statusCode);
            samlResponseFail.setSubStatusCode(subCode);
            samlResponseFail.setMessage(message);
            samlResponseFail.setIssuer(getSpepsResponderMetadataUrl());
            engine.setRequestIssuer(issuer);
            samlResponseFail = engine.generateSTORKAuthnResponseFail(request, samlResponseFail,
                            ipUserAddress, false);
            samlResponseFail.setInResponseTo(inResponseTo);
            prepareRespLoggerBean(PEPSValues.SP_RESPONSE.toString(),
                    samlResponseFail, inResponseTo);
            this.saveLog(AUSPEPSSAML.LOGGER_COM_RESP);
            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "SPEPS - Generating ERROR SAML Response to request with ID {}, error is {} {}",
                    inResponseTo, statusCode, message);

            return samlResponseFail.getTokenSaml();
        } catch (final STORKSAMLEngineException e) {
            LOG.info("BUSINESS EXCEPTION : Error generating SAMLToken", e);
            PEPSErrorUtil.processSAMLEngineException(e, LOG, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML);
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML
                            .errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML
                            .errorMessage()), e);
        }finally {
            getStorkSAMLEngineFactory().releaseEngine(engine);
        }
    }

    /**
     * {@inheritDoc}
     */
    public byte[] getSAMLToken(final Map<String, String> parameters,
                               final String errorCode, final boolean isRequest) {

        String strSamlToken;
        String paramName;
        if (isRequest) {
            paramName = PEPSParameters.SAML_REQUEST.toString();
            strSamlToken = parameters.get(paramName);
        } else {
            paramName = PEPSParameters.SAML_RESPONSE.toString();
            strSamlToken = parameters.get(paramName);
        }
        validateParameter(paramName, strSamlToken, PEPSErrors.valueOf(errorCode));

        return PEPSUtil.decodeSAMLToken(strSamlToken);
    }

    public byte[] getSAMLArtifact(final Map<String, String> parameters,
                                  final String errorCode, final boolean isRequest){
        String paramName = PEPSParameters.SAML_ARTIFACT.toString();
        String strSamlArtifact = parameters.get(paramName);

        return PEPSUtil.decodeSAMLToken(strSamlArtifact);
    }

    /**
     * {@inheritDoc}
     */
    public STORKAuthnRequest processAuthenticationRequest(final byte[] samlToken,
                                                          final Map<String, String> parameters) {
        STORKSAMLEngine engine=null;
        try {

            engine = getStorkSAMLEngineFactory().getEngine(samlSpInstance, getSpepsUtil() == null ? null : getSpepsUtil().getConfigs());

            // validate SAML Token
            final STORKAuthnRequest authnRequest = engine.validateSTORKAuthnRequest(samlToken);

            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "SPEPS - Processing SAML Request with ID {}", authnRequest.getSamlId());

            LOG.trace("Validating parameters.");

            // Get Assertion Consumer URL and validate
            final String assertionURL = authnRequest.getAssertionConsumerServiceURL();
            validateParameter(PEPSParameters.SP_URL.toString(), assertionURL, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPREDIRECT);
            if(SessionHolder.getId()!=null){
                HttpSession session= SessionHolder.getId();
                session.setAttribute(PEPSParameters.SP_URL.toString(), assertionURL);
                session.setAttribute(PEPSParameters.SAML_IN_RESPONSE_TO.toString(), authnRequest.getSamlId());
                session.setAttribute(PEPSParameters.ISSUER.toString(), authnRequest.getIssuer());
            }

            // Get Personal Attribute List and validate
            final IPersonalAttributeList pal = authnRequest.getPersonalAttributeList();
            validateParameter(PEPSParameters.ATTRIBUTE_LIST.toString(), pal.toString(), PEPSErrors.SPROVIDER_SELECTOR_INVALID_ATTR);

            // Get QAA Level and validate
            final String qaa = String.valueOf(authnRequest.getQaa());
            LOG.info("checking QAA {}{}"+ qaa);
            validateParameter(PEPSParameters.SP_QAALEVEL.toString(), qaa, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPQAA);

            parameters.put(PEPSParameters.EIDAS_SERVICE_LOA.toString(), authnRequest.getEidasLoA());

            // Get ProviderName and validate
            final String providerName = authnRequest.getProviderName();
            validateParameter(PEPSParameters.PROVIDER_NAME_VALUE.toString(), providerName, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SP_PROVIDERNAME);
            parameters.put(PEPSParameters.PROVIDER_NAME_VALUE.toString(), providerName);

            // Alias validation : If alias is blank, then we continue the authentication flow: PEPS
            aliasValidation(authnRequest, providerName);



            // Get SP ID (PEPS backwards compatibility)
            final String spId = StringUtils.isBlank(authnRequest.getSPID()) ? providerName : authnRequest.getSPID();

            validateParameter(PEPSParameters.SP_ID.toString(), spId, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPID);
            parameters.put(PEPSParameters.SP_ID.toString(), spId);

            final String cpepsCode = getCountryCode(authnRequest, parameters);

            LOG.debug("Requested country: " + cpepsCode);
            final String cpepsURL = spepsUtil.loadConfigPepsURL(cpepsCode);
            LOG.debug("Citizen Country URL " + cpepsCode + " URL " + cpepsURL);
            authnRequest.setCitizenCountryCode(cpepsCode);
            if(spepsUtil.isEIDAS10(authnRequest.getMessageFormatName())){
                validateRequestLoA(authnRequest,spepsUtil.loadConfigPepsMetadataURL(cpepsCode));
            } else {
                if (spepsUtil.isEidasMessageSupportedOnly()){
                    // Send an error SAML message back - the use of InternalErrorPEPSException should have triggered an error page
                    throw new InvalidParameterPEPSException(
                            PEPSUtil.getConfig(PEPSErrors.MESSAGF_FORMAT_UNSUPPORTED.errorCode()),
                            PEPSUtil.getConfig(PEPSErrors.MESSAGF_FORMAT_UNSUPPORTED.errorMessage()));
                }
            }

            validateParameter(PEPSErrors.CPEPS_REDIRECT_URL.toString(), cpepsURL, PEPSErrors.SPROVIDER_SELECTOR_INVALID_COUNTRY);

            LOG.trace("Checking if SP is reliable");
            parameters.put(PEPSParameters.SAML_IN_RESPONSE_TO.toString(), authnRequest.getSamlId());
            parameters.put(PEPSParameters.ISSUER.toString(), authnRequest.getIssuer());
            parameters.put(PEPSParameters.SP_URL.toString(), assertionURL);
            parameters.put(PEPSParameters.SP_ID.toString(), spId);
            parameters.put(PEPSParameters.SP_QAALEVEL.toString(), qaa);

            // Validate if SP has valid qaalevel and is trustworthy
            if (!spepsUtil.validateSP(parameters)) {
                throw new InvalidParameterPEPSException(
                        PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPQAAID
                                .errorCode()),
                        PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPQAAID
                                .errorMessage()));
            }
            // check if SP is allowed to access requested attribute
            if (!spepsUtil.checkContents(spId, pal)) {
                LOG.info("ERROR : SP can't request this attrs");
                throw new SecurityPEPSException(
                        PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_SPNOTALLOWED
                                .errorCode()),
                        PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_SPNOTALLOWED
                                .errorMessage()));
            }
            if(parameters.containsKey(PEPSParameters.SP_METADATA_URL.toString()) && isIssuedBySelf(authnRequest) ){
                authnRequest.setIssuer(parameters.get(PEPSParameters.SP_METADATA_URL.toString()));
            }

            authnRequest.setDestination(cpepsURL);

            // Checking for antiReplay
            if (!spepsUtil.checkNotPresentInCache(authnRequest.getSamlId(), authnRequest.getCitizenCountryCode())){
                LOG.trace("Stork Audit");
                prepareReqLoggerBean(PEPSValues.SP_REQUEST.toString(), samlToken,
                        authnRequest, authnRequest.getSamlId());
                this.saveLog(AUSPEPSSAML.LOGGER_COM_REQ);
                throw new SecurityPEPSException(
                        PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorCode()),
                        PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorMessage()));
            }

            // Stork Logging
            LOG.trace("Stork Audit");
            prepareReqLoggerBean(PEPSValues.SP_REQUEST.toString(), samlToken, authnRequest, authnRequest.getSamlId());
            this.saveLog(AUSPEPSSAML.LOGGER_COM_REQ);

            return authnRequest;
        } catch (final STORKSAMLEngineException e) {
            // Special case for propagating the error in case of xxe
            PEPSErrorUtil.processSAMLEngineException(e, LOG, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML);
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorMessage()), e);
        }finally {
            getStorkSAMLEngineFactory().releaseEngine(engine);
        }
    }

    private void validateRequestLoA (STORKAuthnRequest authRequest, String idpUrl){
        try{
            String colleagueLoA= SAMLEngineUtils.getServiceLoA(metadataProcessor.getEntityDescriptor(idpUrl));
            if(!StringUtils.isEmpty(colleagueLoA) && !PEPSValidationUtil.isRequestLoAValid(authRequest, colleagueLoA)){
                throw new InternalErrorPEPSException(
                        PEPSUtil.getConfig(PEPSErrors.SERVICE_PROVIDER_INVALID_LOA.errorCode()),
                        PEPSUtil.getConfig(PEPSErrors.SERVICE_PROVIDER_INVALID_LOA.errorMessage()));
            }
        }catch(SAMLEngineException exc){
            LOG.info("cannot retrieve metadata information {}", exc);
        }
    }
    private boolean isIssuedBySelf(STORKAuthnRequest authnRequest){
        if(getSpepsMetadataUrl()!=null && getSpepsMetadataUrl().equalsIgnoreCase(authnRequest.getIssuer())) {
            return true;
        }
        return false;
    }
    /**
     * Alias validation : If alias is blank, then we continue the authentication flow: PEPS
     * backwards compatibility!
     * @param authnRequest
     * @param providerName
     */
    private void aliasValidation(STORKAuthnRequest authnRequest, String providerName) {
        final String alias = authnRequest.getAlias();
        LOG.trace("Alias validation!");
        if (StringUtils.isNotBlank(alias)
                && !StringUtils.lowerCase(providerName).equals(
                StringUtils.lowerCase(alias))
                && !spepsUtil.validateSPCertAlias(providerName, alias)) {

            LOG.info("ERROR : SP's (" + providerName + ") alias validation failed to "
                    + alias);
            throw new SecurityPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPALIAS
                            .errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SPALIAS
                            .errorMessage()));
        }
        LOG.trace("Alias validation succeeded!");
    }

    /**
     * Gets the Country Code.
     *
     * @param authnRequest The Authentication Request object.
     * @param parameters   A map of necessary arguments.
     * @return the country code value.
     */
    private static String getCountryCode(final STORKAuthnRequest authnRequest,
                                         final Map<String, String> parameters) {
        // Country: Mandatory if the destination is a C-PEPS.
        String cpepsCode;
        if (authnRequest.getCitizenCountryCode() == null) {
            cpepsCode = parameters.get(PEPSParameters.COUNTRY.toString());
            authnRequest.setCitizenCountryCode(cpepsCode);
        } else {
            cpepsCode = authnRequest.getCitizenCountryCode();
        }

        // PEPS Compatibility
        if (cpepsCode.endsWith(PEPSValues.PEPS_SUFFIX.toString())) {
            cpepsCode =
                    cpepsCode.replace(PEPSValues.PEPS_SUFFIX.toString(),
                            PEPSValues.EMPTY_STRING.toString());
        }
        return cpepsCode;
    }

    /**
     * Checks if a given parameter and it's value aren't null and their size is
     * between the specified bounds.
     *
     * @param paramName  The name of the parameter to validate.
     * @param paramValue The value of the parameter to validate.
     * @param pepsError  The PEPSERROR value.
     */
    private static void validateParameter(final String paramName,
                                          final String paramValue, final PEPSErrors pepsError) {
        PEPSUtil.validateParameter(AUSPEPSSAML.class.getCanonicalName(), paramName,
                paramValue, PEPSUtil.getConfig(pepsError.errorCode()), PEPSUtil.getConfig(pepsError.errorMessage()));
    }

    /**
     * {@inheritDoc}
     */
    public STORKAuthnRequest generateSpAuthnRequest(
            final STORKAuthnRequest authData) {

        return generateAuthenticationRequest(samlSpInstance, authData);
    }

    /**
     * {@inheritDoc}
     */
    public STORKAuthnRequest generateCpepsAuthnRequest(
            final STORKAuthnRequest authData) {

        final STORKAuthnRequest retAuthData =
                generateAuthenticationRequest(samlCpepsInstance, authData);

        if (retAuthData.getCitizenCountryCode() == null) {
            retAuthData.setCitizenCountryCode(authData.getCitizenCountryCode());
        }
        if (StringUtils.isEmpty(retAuthData.getCountry())) {
            retAuthData.setCountry(authData.getCountry());
        }
        prepareReqLoggerBean(PEPSValues.SPEPS_REQUEST.toString(),
                retAuthData.getTokenSaml(), retAuthData, authData.getSamlId());

        this.saveLog(AUSPEPSSAML.LOGGER_COM_REQ);
        LOG.trace("Logging communication");

        return retAuthData;
    }

    private String extractErrorMessage(String defaultMsg, String errorCode){
        String newErrorMessage=defaultMsg;
        try {
            newErrorMessage =
                    messageSource.getMessage(errorCode, new Object[]{errorCode},
                            Locale.getDefault());
        }catch(NoSuchMessageException nsme){
            LOG.warn("Cannot found the message with the id {} - {}", errorCode, nsme);
        }
        return newErrorMessage;
    }
    /**
     * {@inheritDoc}
     */
    public STORKAuthnRequest processAuthenticationResponse(
            final byte[] samlToken, final STORKAuthnRequest authData,
            final STORKAuthnRequest spAuthData, final String remoteAddr) {
        STORKSAMLEngine engine=null;
        try {
            engine = getStorkSAMLEngineFactory().getEngine(samlCpepsInstance, getSpepsUtil() == null ? null : getSpepsUtil().getConfigs());
            Long cPepsSkew = spepsUtil.loadConfigPepsTimeSkewInMillis(authData.getCitizenCountryCode());
            engine.initRequestedAttributes(authData.getPersonalAttributeList());
            final STORKAuthnResponse authnResponse = engine.validateSTORKAuthnResponse(samlToken, remoteAddr, cPepsSkew);

            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "SPEPS - Processing SAML Response to request with ID {}", authData.getSamlId());
            this.prepareRespLoggerBean(PEPSValues.SPEPS_RESPONSE.toString(),
                    authnResponse, spAuthData.getSamlId());
            this.saveLog(AUSPEPSSAML.LOGGER_COM_RESP);

            LOG.trace("Checking inResponseTo");
            checkInResponseTo(authData.getSamlId(), authnResponse.getInResponseTo());

            checkAntiReplay(samlToken, authData, authnResponse);

            checkCPepsCountryToCitizenCountry(samlToken, authData, authnResponse);

            if(!authnResponse.isFail()) {
                checkResponseLoA(samlToken, authData, authnResponse);
                authData.setEidasLoA(authnResponse.getAssuranceLevel());
            }

            LOG.trace("Checking status code");
            if (!STORKStatusCode.SUCCESS_URI.toString().equals(
                    authnResponse.getStatusCode())) {
                LOG.info("ERROR : Auth not succeed!");

                final String errorCode =
                        PEPSUtil.getStorkErrorCode(authnResponse.getMessage());
                // We only change the error message if we get any error code on the Message!
                // Backwards compatibility
                String errorMessage = authnResponse.getMessage();
                if (StringUtils.isNotBlank(errorCode)) {
                    errorMessage=extractErrorMessage(errorMessage, errorCode);
                }
                final byte[] samlResponseFail =
                        generateErrorAuthenticationResponse(spAuthData.getSamlId(),
                                authData.getOriginalIssuer()!=null?authData.getOriginalIssuer():authData.getIssuer(), spAuthData.getAssertionConsumerServiceURL(),
                                remoteAddr, authnResponse.getStatusCode(),
                                authnResponse.getSubStatusCode(), errorMessage);
                throw new InternalErrorPEPSException(errorCode, errorMessage,
                        PEPSUtil.encodeSAMLToken(samlResponseFail));
            }

            LOG.trace("Checking audience...");
            checkAudienceRestriction(authData.getIssuer(),
                    authnResponse.getAudienceRestriction());

            LOG.trace("Setting internal variables");

            authData.setPersonalAttributeList(authnResponse
                    .getPersonalAttributeList());
            if(authData.getOriginalIssuer()!=null) {
                spAuthData.setIssuer(authData.getOriginalIssuer());
            }
            return authData;
        } catch (final STORKSAMLEngineException e) {
            LOG.info("BUSINESS EXCEPTION : SAML validation error", e.getMessage());
            LOG.debug("BUSINESS EXCEPTION : SAML validation error", e);
            PEPSErrorUtil.processSAMLEngineException(e, LOG, PEPSErrors.COLLEAGUE_RESP_INVALID_SAML);
            //normal processing of the above line will already cause the throw of the below exception
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.COLLEAGUE_RESP_INVALID_SAML.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.COLLEAGUE_RESP_INVALID_SAML
                            .errorMessage()), e);
        }finally{
            getStorkSAMLEngineFactory().releaseEngine(engine);
        }
    }

    /**
     * Compares the stored SAML request id to the incoming SAML response id.
     *
     * @param auRequestID      The stored Id of the SAML request.
     * @param currentRequestId The Id of the incoming SAML response.
     */
    private void checkInResponseTo(final String auRequestID,
                                   final String currentRequestId) {

        if (auRequestID == null || !auRequestID.equals(currentRequestId)) {
            LOG.info(LoggingMarkerMDC.SECURITY_WARNING, "ERROR : Stored request Id ({}) is not the same than response request id ({})", auRequestID, currentRequestId);
            throw new InvalidSessionPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.AU_REQUEST_ID.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.AU_REQUEST_ID.errorMessage()));
        }
    }

    /**
     * Check if the citizen country code is the same than the C-PEPS signing certificate
     * @param samlToken     the samlToken received
     * @param authData      the initial authnRequest
     * @param authnResponse the authnResponse
     */
    private void checkCPepsCountryToCitizenCountry(byte[] samlToken, STORKAuthnRequest authData, STORKAuthnResponse authnResponse) {
        if (checkCitizenCertificateCPepsCertificate && !authData.getCitizenCountryCode().equals(authnResponse.getCountry())){
            LOG.info("ERROR : Signing country for C-PEPS " + authnResponse.getCountry() + " is not the same than the citizen country code " + authData.getCitizenCountryCode());
            prepareReqLoggerBean(PEPSValues.SP_REQUEST.toString(), samlToken,
                    authData, authData.getSamlId());
            this.saveLog(AUSPEPSSAML.LOGGER_COM_REQ);
            throw new InvalidSessionPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.INTERNAL_ERROR.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.INTERNAL_ERROR.errorMessage()));
        }
    }

    /**
     * check the LoA in the response against connector's own LoA
     * @param samlToken
     * @param authData
     * @param authnResponse
     */
    private void checkResponseLoA(byte[] samlToken, STORKAuthnRequest authData, STORKAuthnResponse authnResponse) {
        EidasLoaLevels requestedLevel=EidasLoaLevels.getLevel(authData.getEidasLoA());
        EidasLoaLevels responseLevel= EidasLoaLevels.getLevel(authnResponse.getAssuranceLevel());
        if (requestedLevel!=null && (responseLevel==null || !PEPSValidationUtil.isRequestLoAValid(authData, responseLevel.stringValue()))){
            LOG.info("ERROR : the level of assurance in the response "+authnResponse.getAssuranceLevel()+" does not satisfy the requested level "+requestedLevel);
            prepareReqLoggerBean(PEPSValues.SP_REQUEST.toString(), samlToken, authData, authData.getSamlId());
            this.saveLog(AUSPEPSSAML.LOGGER_COM_REQ);
            throw new InvalidSessionPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.INTERNAL_ERROR.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.INTERNAL_ERROR.errorMessage()));
        }
    }

    /**
     * Check the antireplay cache to control if the samlId has not yet been submitted
     * @param samlToken     the samlToken received
     * @param authData      the initial authnRequest
     * @param authnResponse the authnResponse
     */
    private void checkAntiReplay(byte[] samlToken, STORKAuthnRequest authData, STORKAuthnResponse authnResponse) {
        if (!spepsUtil.checkNotPresentInCache(authnResponse.getSamlId(), authnResponse.getCountry())){
            LOG.info("ERROR : SAMLID " + authnResponse.getSamlId() + "+ for response found in Antireplay cache");
            prepareReqLoggerBean(PEPSValues.SP_REQUEST.toString(), samlToken,
                    authData, authData.getSamlId());
            this.saveLog(AUSPEPSSAML.LOGGER_COM_REQ);
            throw new SecurityPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorMessage()));
        }
    }

    /**
     * {@inheritDoc}
     */
    public byte[] generateAuthenticationResponse(
            final STORKAuthnRequest authData, final String ipUserAddress) {
        STORKSAMLEngine engine=null;
        try {
            engine = getStorkSAMLEngineFactory().getEngine(samlSpInstance, getSpepsUtil() == null ? null : getSpepsUtil().getConfigs());

            STORKAuthnResponse storkResponse = new STORKAuthnResponse();
            storkResponse.setPersonalAttributeList(authData.getPersonalAttributeList());

            //TODO retrieve this from SP metadata
            boolean generateSignedAssertion = Boolean.parseBoolean(spepsUtil == null || spepsUtil.getConfigs() == null ? null : spepsUtil.getConfigs().getProperty(PEPSParameters.RESPONSE_SIGN_ASSERTION.toString()));
            engine.setRequestIssuer(authData.getIssuer());
            // Generate SAMLResponse.
            storkResponse.setIssuer(getSpepsResponderMetadataUrl());
            if( StringUtils.isEmpty(authData.getEidasLoA()) && spepsUtil.isEIDAS10(authData.getMessageFormatName())){
                storkResponse.setAssuranceLevel("dummy");
            }else{
                if (spepsUtil.isEidasMessageSupportedOnly()){
                    // Send an error SAML message back - the use of InternalErrorPEPSException should have triggered an error page
                    throw new InvalidParameterPEPSException(
                            PEPSUtil.getConfig(PEPSErrors.MESSAGF_FORMAT_UNSUPPORTED.errorCode()),
                            PEPSUtil.getConfig(PEPSErrors.MESSAGF_FORMAT_UNSUPPORTED.errorMessage()));
                }
                storkResponse.setAssuranceLevel(authData.getEidasLoA());
            }
            storkResponse = engine.generateSTORKAuthnResponse(authData, storkResponse,
                            ipUserAddress, false, generateSignedAssertion);

            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "SPEPS - Generating SAML Response to request with ID {}", authData.getSamlId());
            storkResponse.setInResponseTo(authData.getSamlId());
            prepareRespLoggerBean(PEPSValues.SP_RESPONSE.toString(), storkResponse,
                    authData.getSamlId());
            AUSPEPSSAML.LOGGER_COM_RESP.info(LoggingMarkerMDC.SAML_EXCHANGE, loggerBean.toString());

            return storkResponse.getTokenSaml();
        } catch (final STORKSAMLEngineException e) {
            LOG.info("ERROR : Error generating SAMLToken", e);
            PEPSErrorUtil.processSAMLEngineException(e, LOG, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML);
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SPEPS_SAML_RESPONSE.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SPEPS_SAML_RESPONSE.errorMessage()), e);
        }finally {
            if(engine!=null) {
                getStorkSAMLEngineFactory().releaseEngine(engine);
            }
        }

    }

    /**
     * Generates a request SAML token based on an authentication request.
     *
     * @param instance String containing the SAML configuration to load.
     * @param authData An authentication request to generate the SAML token.
     * @return An authentication request with the embedded SAML token.
     * @see STORKAuthnRequest
     */
    private STORKAuthnRequest generateAuthenticationRequest(
            final String instance, final STORKAuthnRequest authData) {

        final STORKSAMLEngine engine = getStorkSAMLEngineFactory().getEngine(instance, getSpepsUtil()==null?null:getSpepsUtil().getConfigs());

        try {

            // If there is no SP Country, Then we get it from SAML's Certificate
            if (StringUtils.isBlank(authData.getSpCountry())) {
                authData.setSpCountry(authData.getCountry());
            }
            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "SPEPS - Processing SAML Request with ID {}", authData.getSamlId());
            if(getSpepsMetadataUrl()!=null && !getSpepsMetadataUrl().isEmpty() && PropertiesUtil.isMetadataEnabled()){
                authData.setOriginalIssuer(authData.getIssuer());
                authData.setIssuer(getSpepsMetadataUrl());
            }
            if(spepsUtil.isEIDAS10(authData.getMessageFormatName())){
                authData.setBinding(STORKAuthnRequest.BINDING_EMPTY);
            } else {
                if (spepsUtil.isEidasMessageSupportedOnly()){
                    // Send an error SAML message back - the use of InternalErrorPEPSException should have triggered an error page
                    throw new InvalidParameterPEPSException(
                            PEPSUtil.getConfig(PEPSErrors.MESSAGF_FORMAT_UNSUPPORTED.errorCode()),
                            PEPSUtil.getConfig(PEPSErrors.MESSAGF_FORMAT_UNSUPPORTED.errorMessage()));
                }
            }
            return engine.generateSTORKAuthnRequest(authData);

        } catch (final STORKSAMLEngineException e) {
            LOG.info(instance + " : Error generating SAML Token", e.getMessage());
            LOG.debug(instance + " : Error generating SAML Token", e);
            PEPSErrorUtil.processSAMLEngineException(e, LOG, PEPSErrors.SPROVIDER_SELECTOR_INVALID_SAML);
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML.errorMessage()), e);
        }finally {
            getStorkSAMLEngineFactory().releaseEngine(engine);
        }
    }

    /**
     * Sets all the fields to audit the request.
     *
     * @param opType       The operation type.
     * @param samlObj      The SAML token byte[].
     * @param authnRequest The Authentication Request object.
     * @param spSamlId     The SP's SAML ID.
     * @see STORKAuthnRequest
     */
    private void prepareReqLoggerBean(final String opType, final byte[] samlObj,
                                      final STORKAuthnRequest authnRequest, final String spSamlId) {
        final String hashClassName=getSpepsUtil()!=null && getSpepsUtil().getConfigs()!=null?getSpepsUtil().getConfigs().getProperty(PEPSParameters.PEPS_HASH_DIGEST_CLASS.toString()):null;
        final byte[] tokenHash = PEPSUtil.hashPersonalToken(samlObj, hashClassName);
        loggerBean.setTimestamp(DateUtil.currentTimeStamp().toString());
        loggerBean.setOpType(opType);
        loggerBean.setOrigin(authnRequest.getAssertionConsumerServiceURL());
        loggerBean.setDestination(authnRequest.getDestination());
        loggerBean.setSpApplication(authnRequest.getSpApplication());
        loggerBean.setProviderName(authnRequest.getProviderName());
        loggerBean.setCountry(authnRequest.getCitizenCountryCode());
        loggerBean.setQaaLevel(authnRequest.getQaa());
        loggerBean.setSamlHash(tokenHash);
        loggerBean.setSPMsgId(spSamlId);
        loggerBean.setMsgId(authnRequest.getSamlId());
    }

    /**
     * Sets all the fields to the audit the response.
     *
     * @param opType            The Operation Type.
     * @param authnResponse     The Authentication Response object.
     * @param inResponseToSPReq The SP's SAML Id.
     * @see STORKAuthnRequest
     */
    private void prepareRespLoggerBean(final String opType,
                                       final STORKAuthnResponse authnResponse, final String inResponseToSPReq) {
        final String hashClassName=getSpepsUtil()!=null && getSpepsUtil().getConfigs()!=null?getSpepsUtil().getConfigs().getProperty(PEPSParameters.PEPS_HASH_DIGEST_CLASS.toString()):null;
        final byte[] tokenHash =
                PEPSUtil.hashPersonalToken(authnResponse.getTokenSaml(), hashClassName);
        final String message =
                PEPSValues.SUCCESS.toString() + PEPSValues.EID_SEPARATOR.toString()
                        + PEPSValues.CITIZEN_CONSENT_LOG.toString();
        loggerBean.setTimestamp(DateUtil.currentTimeStamp().toString());
        loggerBean.setOpType(opType);
        loggerBean.setInResponseTo(authnResponse.getInResponseTo());
        loggerBean.setInResponseToSPReq(inResponseToSPReq);
        loggerBean.setMessage(message);
        loggerBean.setSamlHash(tokenHash);
        loggerBean.setMsgId(authnResponse.getSamlId());
    }

    /**
     * Logs the transaction with the Audit log.
     *
     * @param logger The Audit Logger.
     */
    public void saveLog(final Logger logger) {
        logger.info(LoggingMarkerMDC.SAML_EXCHANGE, loggerBean.toString());
    }

    /**
     * Setters and getters
     */

    /**
     * Setter for loggerBean.
     *
     * @param nLoggerBean The loggerBean to set.
     * @see IStorkLogger
     */
    public void setLoggerBean(final IStorkLogger nLoggerBean) {
        this.loggerBean = nLoggerBean;
    }

    /**
     * Getter for loggerBean.
     *
     * @return The loggerBean value.
     * @see IStorkLogger
     */
    public IStorkLogger getLoggerBean() {
        return loggerBean;
    }

    /**
     * Compares the issuer to the audience restriction.
     *
     * @param issuer   The stored SAML request issuer.
     * @param audience The SAML response audience.
     */
    private void checkAudienceRestriction(final String issuer,
                                          final String audience) {

        if (issuer == null || !issuer.equals(audience)) {
            LOG.info("ERROR : Audience is null or not valid");
            throw new InvalidSessionPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.AUDIENCE_RESTRICTION.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.AUDIENCE_RESTRICTION.errorMessage()));
        }
    }

    /**
     * {@inheritDoc}
     */
    public void checkMandatoryAttributes(final STORKAuthnRequest authnData,
                                         final String ipUserAddress) {

        if (authnData==null || !AttributeUtil.checkMandatoryAttributes(authnData.getPersonalAttributeList())) {
            LOG.info("BUSINESS EXCEPTION : Mandatory attribute is missing!");
            String errorMessage =
                    messageSource.getMessage(PEPSUtil.getConfig(PEPSErrors.ATT_VERIFICATION_MANDATORY.errorCode()),
                            new Object[]{PEPSUtil.getConfig(PEPSErrors.ATT_VERIFICATION_MANDATORY.errorCode())},
                            Locale.getDefault());
            final byte[] error =
                    generateErrorAuthenticationResponse(authnData.getSamlId(),
                            authnData.getIssuer(), authnData.getAssertionConsumerServiceURL(),
                            ipUserAddress, PEPSUtil.getConfig(PEPSErrors.ATT_VERIFICATION_MANDATORY.errorCode()),
                            STORKSubStatusCode.REQUEST_DENIED_URI.toString(), errorMessage);
            if (LOG.isInfoEnabled()){
                LOG.info("Missing attributes: " + AttributeUtil.getMissingMandatoryAttributes(authnData.getPersonalAttributeList()));
            }
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.ATT_VERIFICATION_MANDATORY.errorCode()),
                    errorMessage,
                    PEPSUtil.encodeSAMLToken(error));
        }
    }

    public void filterServiceSupportedAttrs (final STORKAuthnRequest authnData, Map<String, String> parameters){
        final String cpepsCode = getCountryCode(authnData, parameters);
        String serviceMetadataURL=getSpepsUtil().loadConfigPepsMetadataURL(cpepsCode);
        if(StringUtils.isEmpty(serviceMetadataURL)){
            LOG.info("The service metadata  for"+cpepsCode+" is not configured, unable to determine the supported attributes");
            return;
        }
        STORKSAMLEngine engine=null;
        try {
            engine = getStorkSAMLEngineFactory().getEngine(samlSpInstance, getSpepsUtil() == null ? null : getSpepsUtil().getConfigs());
            metadataProcessor.checkValidMetadataSignature(serviceMetadataURL, engine);
            IDPSSODescriptor idp=metadataProcessor.getIDPSSODescriptor(serviceMetadataURL);
            List<PersonalAttribute> paToRemove=new ArrayList<PersonalAttribute>();
            List<String> supportedAttrNames=new ArrayList<String>();
            for(Attribute a: idp.getAttributes()){
                supportedAttrNames.add(a.getName());
            }
            IPersonalAttributeList attributeList = authnData.getPersonalAttributeList();
            for(PersonalAttribute pa: attributeList){
                if(!supportedAttrNames.contains(pa.getFullName())){
                    LOG.warn("removing attribute "+pa.getFullName());
                    paToRemove.add(pa);
                }
            }
            for(PersonalAttribute pa: paToRemove) {
                attributeList.remove(pa.getName());
            }
            authnData.setPersonalAttributeList(attributeList);
        }catch(SAMLEngineException e){
            LOG.info("Error filtering supported attributes {}", e);
            PEPSErrorUtil.processSAMLEngineException(e, LOG, PEPSErrors.SAML_ENGINE_NO_METADATA);
            throw new InternalErrorPEPSException(
                    PEPSUtil.getConfig(PEPSErrors.SAML_ENGINE_NO_METADATA.errorCode()),
                    PEPSUtil.getConfig(PEPSErrors.SAML_ENGINE_NO_METADATA.errorMessage()), e);
        }finally {
            getStorkSAMLEngineFactory().releaseEngine(engine);
        }
    }
    /**
     * Setter for samlSpInstance.
     *
     * @param nSamlSpInstance The new SamlSpInstance value.
     */
    public void setSamlSpInstance(final String nSamlSpInstance) {
        this.samlSpInstance = nSamlSpInstance;
    }

    /**
     * Getter for samlSpInstance.
     *
     * @return The samlSpInstance value.
     */
    public String getSamlSpInstance() {
        return samlSpInstance;
    }

    /**
     * Setter for samlCpepsInstance.
     *
     * @param nSamlCpepsInst The new samlCpepsInstance value.
     */
    public void setSamlCpepsInstance(final String nSamlCpepsInst) {
        this.samlCpepsInstance = nSamlCpepsInst;
    }

    /**
     * Getter for samlCpepsInstance.
     *
     * @return The samlCpepsInstance value.
     */
    public String getSamlCpepsInstance() {
        return samlCpepsInstance;
    }

    /**
     * Setter for spepsUtil.
     *
     * @param nSpepsUtil The new spepsUtil value.
     * @see AUSPEPSUtil
     */
    public void setSpepsUtil(final AUSPEPSUtil nSpepsUtil) {
        this.spepsUtil = nSpepsUtil;
    }

    /**
     * Getter for spepsUtil.
     *
     * @return The spepsUtil value.
     * @see AUSPEPSUtil
     */
    public AUSPEPSUtil getSpepsUtil() {
        return spepsUtil;
    }

    /**
     * Getter for messageSource.
     *
     * @return The messageSource value.
     * @see MessageSource
     */
    public MessageSource getMessageSource() {
        return messageSource;
    }

    /**
     * Setter for messageSource.
     *
     * @param nMessageSource The new messageSource value.
     * @see MessageSource
     */
    public void setMessageSource(final MessageSource nMessageSource) {
        this.messageSource = nMessageSource;
    }

    @Override
    public String getMetadata() {
        return "toBeDone";
    }

    public String getSpepsMetadataUrl() {
        return metadataUrl;
    }

    public void setSpepsMetadataUrl(String metadaUrl) {
        this.metadataUrl = metadaUrl;
    }

    public MetadataProcessorI getMetadataProcessor() {
        return metadataProcessor;
    }

    public void setMetadataProcessor(MetadataProcessorI metadataProcessor) {
        this.metadataProcessor = metadataProcessor;
    }

    public String getSpepsResponderMetadataUrl() {
        return metadataResponderUrl;
    }

    public void setSpepsResponderMetadataUrl(String metadataResponderUrl) {
        this.metadataResponderUrl = metadataResponderUrl;
    }
}
